// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/utils/Address.sol";
import "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
import "@chainlink/contracts/src/v0.8/VRFV2WrapperConsumerBase.sol";
import "@openzeppelin/contracts/utils/math/SafeCast.sol";

contract SlotMachine is VRFV2WrapperConsumerBase {
    /* Get Reference Contract Address */
    //Wrapper contract address: (goerli)
    //https://docs.chain.link/vrf/v2/direct-funding/supported-networks/#goerli-testnet
    address constant vrfV2Address = 0x708701a1DfF4f478de54383E49a627eD4852C816;
    //LinkToken contract address: (goerli)
    address constant linkAddress = 0x326C977E6efc84E512bB9C30f76E30c160eD06FB;
    //AggregatorV3Interface contract address: (goerli) to get ETH/USD price
    LinkTokenInterface Link =
        LinkTokenInterface(0x326C977E6efc84E512bB9C30f76E30c160eD06FB);
    AggregatorV3Interface internal ethUsd;

    /* Store user info and each game info and result */
    uint256 internal fee; //fee in LinkToken for VRF service
    mapping(address => uint256) public balance;
    address public owner;
    //Store each game info
    enum GameResult {
        Null,
        First,
        Second,
        Third
    }
    struct Game {
        uint256 id;
        uint256 amount;
        address payable player;
        GameResult result;
        bool isReturned;
    }
    //map gameId to gameInfo
    mapping(uint256 => Game) public games;
    uint256 public gameId = 1; //Initialzie gameId to 1
    //map randomnumber requestID generated by chainlink to gameID
    mapping(uint256 => uint256) public reqToGameId;

    /*Declare events that keep track of eth transfer and game result*/
    event Withdraw(address indexed receiver, uint256 amount);
    event Received(address indexed sender, uint256 amount);
    event Result(
        uint256 id,
        uint256 amount,
        address indexed player,
        uint256 winAmount,
        GameResult indexed result,
        uint256 time
    );
    event AfterSpin(
        uint256 indexed _id,
        uint256 _firstNum,
        uint256 _secondNum,
        uint256 _thirdNum
    );
    struct SpinReturnedNum {
        uint _first;
        uint _second;
        uint _third;
    }
    //keep track of game count for player
    mapping(address => uint256) public playerToGameCount;
    //map player address to a list of gameId
    mapping(address => mapping(uint256 => uint256)) public playerToGameIds;
    //map gameId to returned randomNum
    mapping(uint256 => SpinReturnedNum) public allReturnedNum;

    /*Params for chainlink VRFV2 */
    uint32 constant callbackGasLimit = 600000;
    uint16 requestConfirmations = 3;
    uint32 numWords = 3;

    /*BetAmount limits*/
    uint256 public minBetAmount = 10000000000000; //0.00001 ETH
    uint256 public maxBetAmount = 1000000000000000; //0.001 ETH

    /* Initialize contract with initial link Token to send fees for VRF2 Coordinator*/
    constructor() payable VRFV2WrapperConsumerBase(linkAddress, vrfV2Address) {
        owner = msg.sender;
        fee = 3.78 * 10**18;
        ethUsd = AggregatorV3Interface(
            0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e
        );
    }

    /**Modifer: only owner */
    modifier onlyOwner() {
        require(msg.sender == owner, "Not admin");
        _;
    }

    /**  Main function: 
     *   spin() - user trigger and send request random number, update game status
     *   verdict()- internal, triggered by chainlink callback function with random numbers. Calculate and emit result, update game status
     *   
    /**  Utils function:
     *   releaseBal() - user withdraw their ETH balance;
     *   withdrawEth()- (onlyOwner)owner take all eth from contract;
     *   withdrawLink()-(onlyOwner)owner take all link from contract;
     *   receive()- allow this contract to recieve eth 
     */
    /**  Interface function with chainlink and aggregator:
     *   ethInUsd()- latest eth/usd price from Chainlink
     *   requestRandomWords()- send request to Chainlink. call VRFV2ConsumerBase requestRandomness()- (3) params . requestConfirmations, callbackGasLimit, numWords.
     *   fulfillRandomWords()- callback function required by VRFV2Wrapper
     */

    /**Main functions*/
    function spin() public payable returns (bool) {
        //Check user is eligible to play; Check contract has enough ETH;
        require(!Address.isContract(msg.sender), "Not EOA");
        require(
            address(this).balance > 3 * maxBetAmount,
            "Sorry! We need to recharge our wallet."
        );
        //Check msg.value <maxBetAmount, >minBetAmount
        require(
            msg.value >= minBetAmount && msg.value <= maxBetAmount,
            "Not valid betAmount"
        );
        //Check contract instance has enough link token
        require(
            Link.balanceOf(address(this)) >= fee,
            "Sorry! We need to recharge with more link tokens."
        );
        //Update Game Id, starting from 0
        uint _amount = msg.value;
        games[gameId] = Game(
            gameId,
            _amount,
            payable(msg.sender),
            GameResult(0),
            false
        );
        //update game count for player
        playerToGameCount[msg.sender] += 1;
        uint count = playerToGameCount[msg.sender];
        //update gameId to player game info
        playerToGameIds[msg.sender][count] = gameId;
        //Request random number and map generated requestId to gameId
        uint requestId = requestRandomWords();
        reqToGameId[requestId] = gameId;
        //Update Game Id
        gameId = gameId + 1;
        return true;
    }

    //verdict function is internal to be called by chainlink callback function fulfillRandomness()
    function verdict(uint256 _id, uint[] memory _random) internal {
        //Get three numbers from random numbers and check winning or not
        uint firstNum = (_random[0] % 7) + 1;
        uint secondNum = (_random[1] % 7) + 1;
        uint thirdNum = (_random[2] % 7) + 1;
        allReturnedNum[_id] = SpinReturnedNum(firstNum, secondNum, thirdNum);
        uint winAmount;
        uint betAmount = games[_id].amount;
        games[_id].isReturned = true;
        //emit AfterSpin
        emit AfterSpin(_id, firstNum, secondNum, thirdNum);
        ///First prize: jackpot
        if (firstNum == 7 && secondNum == 7 && thirdNum == 7) {
            winAmount = betAmount + ((betAmount * 50) / 100);
            games[_id].result = GameResult(1);
        }
        ///Second prize
        else if (
            firstNum == secondNum &&
            secondNum == thirdNum &&
            thirdNum == firstNum
        ) {
            winAmount = betAmount + ((betAmount * 30) / 100);
            games[_id].result = GameResult(2);
        }
        ///Third prize
        else if (
            firstNum == secondNum ||
            secondNum == thirdNum ||
            thirdNum == firstNum
        ) {
            winAmount = betAmount + ((betAmount * 10) / 100);
            games[_id].result = GameResult(3);
        }
        //Update user balance
        address player = games[_id].player;
        balance[player] += winAmount;
        //Emit result
        emit Result(
            _id,
            betAmount,
            player,
            winAmount,
            games[_id].result,
            block.timestamp
        );
    }

    /**Interface functions*/
    function requestRandomWords() internal returns (uint _id) {
        //require contract has enough Link token to request
        require(
            Link.balanceOf(address(this)) >= fee,
            "Sorry, we need to recharge LINK Token"
        );
        _id = requestRandomness(
            callbackGasLimit,
            requestConfirmations,
            numWords
        );
        return _id;
    }

    function fulfillRandomWords(uint256 _id, uint256[] memory _randomWords)
        internal
        override
    {
        //verify request exist
        require(reqToGameId[_id] > 0, "Request not found");
        uint256 _gameId = reqToGameId[_id];
        uint256[] memory _outputRandom = _randomWords;
        verdict(_gameId, _outputRandom);
    }

    //One usd in Wei
    function usdInWei() internal view returns (int _usdInWei) {
        //get 1 ETH in USD, return value represent 8 decimals (10**8)
        (, int _ethInUsd, , , ) = ethUsd.latestRoundData();
        //get 1 USD in WEI
        _usdInWei = (10 * 10**26) / _ethInUsd;
        return _usdInWei;
    }

    /**Util funtions */
    function releaseBal() public returns (bool) {
        //get balance of the user and require user balance >0
        require(balance[msg.sender] > 0, "Nothing to withdraw");
        //UPdate user balance to 0;
        uint _value = balance[msg.sender];
        balance[msg.sender] = 0;
        //send fund to user
        (bool success, ) = msg.sender.call{value: _value}("");
        if (success) {
            emit Withdraw(msg.sender, balance[msg.sender]);
        }
        return success;
    }

    function withdrawEth() public onlyOwner returns (bool) {
        require(address(this).balance > 0, "Nothing to withdraw");
        (bool success, ) = owner.call{value: address(this).balance}("");
        if (success) {
            emit Withdraw(owner, address(this).balance);
        }
        return success;
    }

    function contractEthBal() public view onlyOwner returns (uint256) {
        uint _balance = address(this).balance;
        return _balance;
    }

    function withdrawLink() public onlyOwner {
        uint _balance = Link.balanceOf(address(this));
        bool success = Link.transfer(owner, _balance);
        require(success, "Error, unable to transfer");
    }

    function contractLinkBal() public view onlyOwner returns (uint256) {
        uint _balance = Link.balanceOf(address(this));
        return _balance;
    }

    function setMinBetAmount(uint256 _amount) public onlyOwner {
        minBetAmount = _amount;
    }

    function setMaxBetAmount(uint256 _amount) public onlyOwner {
        require(
            _amount > minBetAmount,
            "Amount should be greater than MinBetAmount!"
        );
        maxBetAmount = _amount;
    }

    receive() external payable {
        emit Received(msg.sender, msg.value);
    }
}
